**1. 进程之间如何通信**

**答： 可以通过队列的形式，示例如下**

**from multiprocessing import Queue, Process**

**import time, random**

**# 要写入的数据**

**list1 = ["java", "Python", "JavaScript"]**

**def write(queue)：**

​    **"""**

​    **向队列中添加数据**

​    **：param queue：**

​    **：return：**

​    **"""**

​    **for value in list1：**

​        **print(f"正在向队列中添加数据-->{value}")**

​        **# put_nowait 不会等待队列有空闲位置再放入数据，如果数据放入不成功就直接崩溃,比如数据满了。put 的话就会一直等待**

​        **queue.put_nowait(value)**

​        **time.sleep(random.random())**

**def read(queue)：**

​    **while True：**

​        **# 判断队列是否为空**

​        **if not queue.empty()：**

​            **# get_nowait 队列为空，取值的时候不等待，但是取不到值那么直接崩溃了**

​            **value = queue.get_nowait()**

​            **print(f'从队列中取到的数据为-->{value}')**

​            **time.sleep(random.random())**

​        **else：**

​            **break**

**if __name__ == '__main__'：**

​    **# 父进程创建出队列，通过参数的形式传递给子进程**

​    **#queue = Queue(2)**

​    **queue = Queue()**

​    **# 创建两个进程 一个写数据 一个读数据**

​    **write_data = Process(target=write, args=(queue,))**

​    **read_data = Process(target=read, args=(queue,))**

​    **# 启动进程 写入数据**

​    **write_data.start()**

​    **# 使用 join 等待写数据结束**

​    **write_data.join()**

​    **# 启动进程  读取数据**

​    **print('\*' \* 20)**

​    **read_data.start()**

​    **# 使用 join  等待读数据结束**

​    **read_data.join()**

​    **print('所有的数据都写入并读取完成。。。')**



**2. 简述 GIL**

**答： GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。**

**线程释放 GIL 锁的情况：在 IO 操作等可能会引起阻塞的 systemcall 之前,可以暂时释放 GIL，但在执行完毕后, 必须重新获取 GIL，Python3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python2.x，tickets 计数达到 100 。**

**Python 使用多进程是可以利用多核的 CPU 资源的。**

**多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁。**



**3. 说一说多线程，多进程和协程的区别。**

**答： 概念：**

**进程：**

**进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,**

**进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，**

**不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，**

**所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。**

**线程：**

**线程是进程的一个实体,是 CPU 调度和分派的基本单位,**

**它是比进程更小的能独立运行的基本单位.**

**线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),**

**但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。**

**线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。**

**协程：**

**协程是一种用户态的轻量级线程，协程的调度完全由用户控制。**

**协程拥有自己的寄存器上下文和栈。**

**协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，**

**直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。**

**区别： 进程与线程比较： 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别：**

**1) 地址空间：线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，**

**而进程有自己独立的地址空间**

**2) 资源拥有：进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源**

**3) 线程是处理器调度的基本单位,但进程不是**

**4) 二者均可并发执行**

**5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，**

**但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制**

**协程与线程进行比较：**

**1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样 Python 中则能使用多核 CPU。**

**2) 线程进程都是同步机制，而协程则是异步**

**3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态**



**4. 什么是粘包？ socket 中造成粘包的原因是什么？ 哪些情况会发生粘包现象？**

**答：TCP 是流式协议，只有字节流，流是没有边界的，根部就不存在粘包一说，一般粘包都是业务上没处理好造成的。**

**但是在描述这个现象的时候，可能还得说粘包。TCP 粘包通俗来讲，就是发送方发送的多个数据包，到接收方后粘连在一起，导致数据包不能完整的体现发送的数据。**

**导致 TCP 粘包的原因，可能是发送方的原因，也有可能是接受方的原因。**

**发送方 由于 TCP 需要尽可能高效和可靠，所以 TCP 协议默认采用 Nagle 算法，以合并相连的小数据包，再一次性发送，以达到提升网络传输效率的目的。但是接收方并不知晓发送方合并数据包，而且数据包的合并在 TCP 协议中是没有分界线的，所以这就会导致接收方不能还原其本来的数据包。**

**接收方 TCP 是基于“流”的。网络传输数据的速度可能会快过接收方处理数据的速度，这时候就会导致，接收方在读取缓冲区时，缓冲区存在多个数据包。在 TCP 协议中接收方是一次读取缓冲区中的所有内容，所以不能反映原本的数据信息。**

**一般的解决方案大概下面几种：**

**发送定长包。如果每个消息的大小都是一样的，那么在接收对等方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。**

**包尾加上\r\n 标记。FTP 协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。**

**包头加上包体长度。包头是定长的 4 个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。**

**并发**



**5. 简要介绍三次握手和四次挥手**

**答： 三次握手 第一次握手：主机 A 发送同步报文段（SYN）请求建立连接。 第二次握手：主机 B 听到连接请求，就将该连接放入内核等待队列当中，并向主机 A 发送针对 SYN 的确认 ACK，同时主机 B 也发送自己的请求建立连接（SYN）。 第三次握手：主机 A 针对主机 BSYN 的确认应答 ACK。**

**四次挥手 第一次挥手：当主机 A 发送数据完毕后，发送 FIN 结束报文段。 第二次挥手：主机 B 收到 FIN 报文段后，向主机 A 发送一个确认序号 ACK（为了防止在这段时间内，对方重传 FIN 报文段）。 第三次挥手：主机 B 准备关闭连接，向主机 A 发送一个 FIN 结束报文段。 第四次挥手：主机 A 收到 FIN 结束报文段后，进入 TIME_WAIT 状态。并向主机 B 发送一个 ACK 表示连接彻底释放。**

**除此之外经常看的问题还有，为什么 2、3 次挥手不能合在一次挥手中？ 那是因为此时 A 虽然不再发送数据了，但是还可以接收数据，B 可能还有数据要发送给 A，所以两次挥手不能合并为一次。**